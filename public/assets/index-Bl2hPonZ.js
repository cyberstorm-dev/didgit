import{b as X,t as _e,c as ie,v as F,F as Se,M as xe,n as de,o as J,e as se,f as ce,h as ue,j as le,k as fe,d as ge,l as Ae,K as Te,p as he,q as G,r as z,u as N,w as ye,C as He,x as W,H as ke,a3 as Ke,B as re,y as Oe,z as Re,A as ze}from"./kernelAccountClient-CqV0UdJt.js";import{j as x,G as Ne,N as Fe,O as Le,P as Ve,Q as Pe,R as Ue,S as Ye,w as U,T as q,p as Z,K as L,V as we,x as Ce,W as Be,X as We,t as V,g as ee,f as Q,z as O,k as H,c as v,i as Ge,h as te,l as pe,v as Ee,m as Ie,o as me,Y as $e,q as je,r as qe,u as Qe}from"./index-BOkJ5mb5.js";import{b as Xe,K as k,V as K,e as ve,D as Je,M as De,d as Ze}from"./constants-BdYsUssb.js";function et({abi:e,address:t,client:n}){const a=n,[o,s]=a?"public"in a&&"wallet"in a?[a.public,a.wallet]:"public"in a?[a.public,void 0]:"wallet"in a?[void 0,a.wallet]:[a,a]:[void 0,void 0],C=o!=null,I=s!=null,f={};let A=!1,h=!1,m=!1;for(const u of e)if(u.type==="function"?u.stateMutability==="view"||u.stateMutability==="pure"?A=!0:h=!0:u.type==="event"&&(m=!0),A&&h&&m)break;return C&&(A&&(f.read=new Proxy({},{get(u,w){return(...c)=>{const{args:d,options:g}=Y(c);return x(o,Ne,"readContract")({abi:e,address:t,functionName:w,args:d,...g})}}})),h&&(f.simulate=new Proxy({},{get(u,w){return(...c)=>{const{args:d,options:g}=Y(c);return x(o,Fe,"simulateContract")({abi:e,address:t,functionName:w,args:d,...g})}}})),m&&(f.createEventFilter=new Proxy({},{get(u,w){return(...c)=>{const d=e.find(D=>D.type==="event"&&D.name===w),{args:g,options:E}=j(c,d);return x(o,Le,"createContractEventFilter")({abi:e,address:t,eventName:w,args:g,...E})}}}),f.getEvents=new Proxy({},{get(u,w){return(...c)=>{const d=e.find(D=>D.type==="event"&&D.name===w),{args:g,options:E}=j(c,d);return x(o,Ve,"getContractEvents")({abi:e,address:t,eventName:w,args:g,...E})}}}),f.watchEvent=new Proxy({},{get(u,w){return(...c)=>{const d=e.find(D=>D.type==="event"&&D.name===w),{args:g,options:E}=j(c,d);return x(o,Pe,"watchContractEvent")({abi:e,address:t,eventName:w,args:g,...E})}}}))),I&&h&&(f.write=new Proxy({},{get(u,w){return(...c)=>{const{args:d,options:g}=Y(c);return x(s,Ue,"writeContract")({abi:e,address:t,functionName:w,args:d,...g})}}})),(C||I)&&h&&(f.estimateGas=new Proxy({},{get(u,w){return(...c)=>{const{args:d,options:g}=Y(c);return x(o??s,Ye,"estimateContractGas")({abi:e,address:t,functionName:w,args:d,...g,account:g.account??s.account})}}})),f.address=t,f.abi=e,f}function Y(e){const t=e.length&&Array.isArray(e[0]),n=t?e[0]:[],a=(t?e[1]:e[0])??{};return{args:n,options:a}}function j(e,t){let n=!1;Array.isArray(e[0])?n=!0:e.length===1?n=t.inputs.some(s=>s.indexed):e.length===2&&(n=!0);const a=n?e[0]:void 0,o=(n?e[1]:e[0])??{};return{args:a,options:o}}function oe(e){return!e||typeof e!="object"||!("BYTES_PER_ELEMENT"in e)?!1:e.BYTES_PER_ELEMENT===1&&e.constructor.name==="Uint8Array"}function tt(e){return at(e)}function at(e){const t=U(q(e.from)),n=Z(oe(e.salt)?e.salt:U(e.salt),{size:32}),a="bytecodeHash"in e?oe(e.bytecodeHash)?e.bytecodeHash:U(e.bytecodeHash):L(e.bytecode,"bytes");return q(we(L(Ce([U("0xff"),t,n,a])),12))}const nt=async(e,t)=>{const{address:n}=t,a=await x(e,Be,"getStorageAt")({address:n,slot:Xe});if(!a)throw new Error("Kernel implementation address not found");const o=we(a,12),s=We(o)?o:V(o);return q(s)},st={"0.0.2 - 0.2.4":"0xd9AB5096a832b9ce79914329DAEE236f8Eea0390","0.3.0":"0x8104e3Ad430EA6d354d013A6789fDFc71E671c43",">=0.3.1":"0x845ADb2C711129d4f3966735eD98a9F09fC4cE57"},$=(e,t,n)=>{var o;F(e.version,t);const a=(o=Object.entries(st).find(([s])=>Se(t,s)))==null?void 0:o[1];if(!a&&!n)throw new Error(`Validator not found for Kernel version: ${t}`);return n??a??O};async function be(e,{signer:t,entryPoint:n,kernelVersion:a,validatorAddress:o}){const s=$(n,a,o),C=await X({signer:t}),I=await ee(e);return{..._e({address:C.address,async signMessage({message:A}){return Q(e,{account:C,message:A})},async signTransaction(A,h){throw new Error("Smart account signer doesn't need to sign transactions")},async signTypedData(A){return C.signTypedData(A)}}),supportedKernelVersions:a,validatorType:"SECONDARY",address:s,source:"ECDSAValidator",getIdentifier(){return s},async getEnableData(){return C.address},async getNonceKey(A,h){return h||0n},async signUserOperation(A){const h=ie({userOperation:{...A,signature:"0x"},entryPointAddress:n.address,entryPointVersion:n.version,chainId:I});return await Q(e,{account:C,message:{raw:h}})},async getStubSignature(){return"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c"},async isEnabled(A,h){return!1}}}const rt=async(e,t,n)=>{F(t.version,n);const a=k[n];return t.version==="0.6"?await ot(e,a.factoryAddress):it(a.accountImplementationAddress)},ot=async(e,t)=>await et({address:t,abi:[{type:"function",name:"initCodeHash",inputs:[],outputs:[{name:"result",type:"bytes32",internalType:"bytes32"}],stateMutability:"view"}],client:e}).read.initCodeHash(),it=e=>{if(!Ge(e))throw new Error("Invalid implementation address");const t=v(["0x603d3d8160223d3973",e,"0x6009","0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076","0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3"]);return L(t)},dt=(e,t,n)=>{const a=V(t,{size:32}),o=H({abi:xe,functionName:"initialize",args:[n,e]}),s=Ce([o,a]),C=BigInt(L(s)),I=BigInt("0xffffffffffffffffffffffff");return V(C&I,{size:32})},ct=(e,t,n,a,o,s,C)=>{const I=V(t,{size:32});let f;if(s==="0.3.0"){f=H({abi:de,functionName:"initialize",args:[v([K.SECONDARY,o]),n,e,a]});const h=v([f,I]);return L(h)}f=H({abi:J,functionName:"initialize",args:[v([K.SECONDARY,o]),n,e,a,C]});const A=v([f,I]);return L(A)};async function wt(e){F(e.entryPoint.version,e.kernelVersion);const t=k[e.kernelVersion],n=$(e.entryPoint,e.kernelVersion),a=await(async()=>{if("initCodeHash"in e&&e.initCodeHash)return e.initCodeHash;if("publicClient"in e&&e.publicClient)return await rt(e.publicClient,e.entryPoint,e.kernelVersion);throw new Error("Either initCodeHash or publicClient must be provided")})();let o;if(e.entryPoint.version==="0.6")o=dt(e.eoaAddress,e.index,n);else{const s="hookAddress"in e&&e.hookAddress?e.hookAddress:O,C="hookData"in e&&e.hookData?e.hookData:"0x",I="initConfig"in e&&e.initConfig?e.initConfig:[];o=ct(e.eoaAddress,e.index,s,C,n,e.kernelVersion,I)}return tt({bytecodeHash:a,opcode:"CREATE2",from:t.factoryAddress,salt:o})}const ut=({entryPointVersion:e,kernelVersion:t,validatorAddress:n,validatorData:a})=>{const o=v([K.SECONDARY,n]);return t==="0.3.0"?H({abi:de,functionName:"initialize",args:[o,O,a,"0x"]}):H({abi:J,functionName:"initialize",args:[o,O,a,"0x",[]]})},lt=async({entryPointVersion:e,kernelVersion:t,validatorData:n,index:a,factoryAddress:o,validatorAddress:s})=>{const C=ut({entryPointVersion:e,kernelVersion:t,validatorAddress:s,validatorData:n});return H({abi:Te,functionName:"deployWithFactory",args:[o,C,V(a,{size:32})]})},B=async(e,t,n)=>{const a=await nt(e,{address:t});return te(a,k[n].accountImplementationAddress)};async function Ct(e,{entryPoint:t,signer:n,index:a=0n,address:o,migrationVersion:s,pluginMigrations:C}){if(t.version==="0.6")throw new Error("EntryPointV0.6 is not supported for migration");F(t.version,s.from),F(t.version,s.to);const I=k[s.from],f=$(t,s.from),A=$(t,s.to),h=await X({signer:n});let m;const u=async()=>m||(m=e.chain?e.chain.id:await x(e,ee,"getChainId")({}),m),w=async()=>lt({entryPointVersion:t.version,factoryAddress:I.factoryAddress,index:a,kernelVersion:s.from,validatorAddress:f,validatorData:h.address}),c=async()=>({factory:I.metaFactoryAddress??O,factoryData:await w()});let d=o??await(async()=>{const{factory:l,factoryData:p}=await c();return await se(e,{factory:l,factoryData:p,entryPointAddress:t.address})})(),g=await B(e,d,s.to);const E={pendingPlugins:C||[],allInstalled:!1},D=async()=>{if(!E.pendingPlugins.length||E.allInstalled){E.allInstalled=!0;return}const l=await Promise.all(E.pendingPlugins.map(p=>Ae(e,{address:d,plugin:p})));E.pendingPlugins=E.pendingPlugins.filter((p,r)=>!l[r]),E.allInstalled=E.pendingPlugins.length===0};await D();const M={address:(t==null?void 0:t.address)??ve,abi:((t==null?void 0:t.version)??"0.7")==="0.6"?ce:ue,version:(t==null?void 0:t.version)??"0.7"};return le({kernelVersion:s.to,kernelPluginManager:await ge(e,{entryPoint:t,kernelVersion:s.to,chainId:await u(),sudo:await be(e,{entryPoint:t,signer:h,kernelVersion:s.to,validatorAddress:A})}),factoryAddress:(await c()).factory,generateInitCode:w,accountImplementationAddress:k[s.to].accountImplementationAddress,encodeModuleInstallCallData:async()=>{throw new Error("Not implemented")},nonceKeyManager:fe({source:{get:()=>0,set:()=>{}}}),client:e,entryPoint:M,getFactoryArgs:c,async getAddress(){if(d)return d;const{factory:l,factoryData:p}=await c();return d=await se(e,{factory:l,factoryData:p,entryPointAddress:t.address}),d},async encodeDeployCallData(l){throw new Error("Not implemented")},async encodeCalls(l,p){await D();const r=[];if(E.pendingPlugins.length>0&&t.version==="0.7")for(const y of E.pendingPlugins)r.push(ye(d,y));g=g||await B(e,d,s.to);let i=l;if(g)i=[...r,...l];else{const y=k[s.to].accountImplementationAddress,_={to:d,data:H({abi:He,functionName:"upgradeTo",args:[y]}),value:0n};if(!te(f,A)){const b=v([K.SECONDARY,Z(A,{size:20,dir:"right"})]),S={to:d,data:H({abi:J,functionName:"changeRootValidator",args:[b,O,h.address,"0x"]}),value:0n};i=[_,S,...r,...l]}i=[_,...r,...l]}return W(i,p)},async sign({hash:l}){return this.signMessage({message:l})},async signMessage({message:l,useReplayableSignature:p}){g=g||await B(e,d,s.to);const r=me(l),i=g?s.to:s.from,y=i==="0.3.0"?"0.3.0-beta":i,_=await G(r,{name:"Kernel",chainId:m,version:y,verifyingContract:d},p);let b=await h.signMessage({message:{raw:_}});return z(N.ERC1271_WITH_VALIDATOR,y)?(p&&z(N.ERC1271_REPLAYABLE,y)&&(b=v([De,b])),v([K.SUDO,b])):b},async signTypedData(l){const{message:p,primaryType:r,types:i,domain:y}=l,_={EIP712Domain:pe({domain:y}),...i};Ee({domain:y,message:p,primaryType:r,types:_});const b=Ie(l);g=g||await B(e,d,s.to);const S=g?s.to:s.from,R=S==="0.3.0"?"0.3.0-beta":S,T=await G(b,{name:"Kernel",chainId:m,version:R,verifyingContract:d}),P=await h.signMessage({message:{raw:T}});return z(N.ERC1271_WITH_VALIDATOR,R)?v([K.SUDO,P]):P},async getNonce(l){const p=ft(f,l==null?void 0:l.key);return he(e,{address:d,entryPointAddress:t.address,key:p})},async getStubSignature(){return Je},async signUserOperation(l){const{chainId:p=await u(),...r}=l,i=ie({userOperation:{...r,sender:r.sender??d,signature:"0x"},entryPointAddress:t.address,entryPointVersion:t.version,chainId:p});return await Q(e,{account:h,message:{raw:i}})}})}const ft=(e,t=0n)=>{if(t>$e)throw new Error("nonce key must be equal or less than 2 bytes(maxUint16) for Kernel version v0.7");const n=Ze.DEFAULT,a=K.SUDO,o=Z(v([n,a,e,V(t,{size:2})]),{size:24});return BigInt(o)};function pt(e){return ke({...e,account:e.account,userOperation:{...e.userOperation,prepareUserOperation:async(t,n)=>{const a=n.authorization||await e.account.signAuthorization(),o={...n,authorization:a};return await Ke(t,o)}}})}const gt=(e,t,{accountImplementationAddress:n,factoryAddress:a,metaFactoryAddress:o})=>{F(e,t);const s=k[t];if(!s)throw new Error(`No addresses found for kernel version ${t}`);return{accountImplementationAddress:n??s.accountImplementationAddress,factoryAddress:s.factoryAddress,metaFactoryAddress:s.metaFactoryAddress??O}};async function Et(e,{signer:t,plugins:n,entryPoint:a,accountImplementationAddress:o,kernelVersion:s,pluginMigrations:C,eip7702Auth:I}){var p;const{accountImplementationAddress:f}=gt(a.version,s,{accountImplementationAddress:o,factoryAddress:void 0,metaFactoryAddress:void 0});let A,h;typeof t=="object"&&t!==null&&"account"in t&&(h=(p=t.account)==null?void 0:p.address);const m=await X({signer:t,address:h}),u=m.address,w=async()=>A||(A=e.chain?e.chain.id:await x(e,ee,"getChainId")({}),A),c=await ge(e,{sudo:await be(e,{signer:m,entryPoint:a,kernelVersion:s}),entryPoint:a,kernelVersion:s,chainId:await w()}),d=async()=>"0x",g=async()=>({factory:void 0,factoryData:void 0}),E=async()=>{const r=await je(e,{address:u});if(!r||r.length===0||!r.toLowerCase().startsWith(`0xef0100${f.slice(2).toLowerCase()}`)){if(I&&!te(I.address,f))throw new Error("EIP-7702 authorization delegate address does not match account implementation address");const i=I??await qe(e,{account:m,address:f,chainId:await w()});if(!await Qe({authorization:i,address:u}))throw new Error("Authorization verification failed");return i}},D={address:(a==null?void 0:a.address)??ve,abi:((a==null?void 0:a.version)??"0.7")==="0.6"?ce:ue,version:(a==null?void 0:a.version)??"0.7"},M={pendingPlugins:C||[],allInstalled:!1},l=async()=>{if(!M.pendingPlugins.length||M.allInstalled){M.allInstalled=!0;return}const r=await Promise.all(M.pendingPlugins.map(i=>Ae(e,{address:u,plugin:i})));M.pendingPlugins=M.pendingPlugins.filter((i,y)=>!r[y]),M.allInstalled=M.pendingPlugins.length===0};return await l(),le({kernelVersion:s,kernelPluginManager:c,accountImplementationAddress:f,factoryAddress:void 0,generateInitCode:d,encodeModuleInstallCallData:async()=>await c.encodeModuleInstallCallData(u),nonceKeyManager:fe({source:{get:()=>0,set:()=>{}}}),client:e,entryPoint:D,getFactoryArgs:g,async getAddress(){return u},signAuthorization:E,async encodeDeployCallData(r){return a.version==="0.6"?Re(r):ze(r)},async encodeCalls(r,i){if(await l(),M.pendingPlugins.length>0&&a.version==="0.7"&&c.activeValidatorMode==="sudo"){const y=[];for(const _ of M.pendingPlugins)y.push(ye(u,_));return W([...r,...y],i,n!=null&&n.hook?!0:void 0)}return r.length===1&&(!i||i==="call")&&r[0].to.toLowerCase()===u.toLowerCase()?r[0].data??"0x":a.version==="0.6"?Oe(r,i):n!=null&&n.hook?W(r,i,!0):W(r,i)},async sign({hash:r}){return this.signMessage({message:r})},async signMessage({message:r,useReplayableSignature:i}){const y=me(r),{name:_,chainId:b,version:S}=await re(e,u,s,A),R=await G(y,{name:_,chainId:Number(b),version:S,verifyingContract:u},i);let T=await c.signMessage({message:{raw:R}});return z(N.ERC1271_WITH_VALIDATOR,S)?(i&&z(N.ERC1271_REPLAYABLE,S)&&(T=v([De,T])),v([c.getIdentifier(),T])):T},async signTypedData(r){const{message:i,primaryType:y,types:_,domain:b}=r,S={EIP712Domain:pe({domain:b}),..._};Ee({domain:b,message:i,primaryType:y,types:S});const R=Ie(r),{name:T,chainId:P,version:ae}=await re(e,u,s,A),Me=await G(R,{name:T,chainId:Number(P),version:ae,verifyingContract:u}),ne=await c.signMessage({message:{raw:Me}});return z(N.ERC1271_WITH_VALIDATOR,ae)?v([c.getIdentifier(),ne]):ne},async getNonce(r){const i=await c.getNonceKey(u,r==null?void 0:r.key);return he(e,{address:u,entryPointAddress:a.address,key:i})},async getStubSignature(r){if(!r)throw new Error("No user operation provided");return c.getStubSignature(r)},async signUserOperation(r){const{chainId:i=await w(),...y}=r;return c.signUserOperation({...y,sender:y.sender??await this.getAddress(),chainId:i})}})}export{Et as create7702KernelAccount,pt as create7702KernelAccountClient,Ct as createEcdsaKernelMigrationAccount,wt as getKernelAddressFromECDSA,$ as getValidatorAddress,st as kernelVersionRangeToValidator,be as signerToEcdsaValidator};
